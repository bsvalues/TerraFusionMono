"""
Data Quality Models

This module defines the database models for data quality monitoring and validation.
"""

import datetime
import json
from app import db
from sqlalchemy import JSON
from sqlalchemy.dialects.postgresql import JSONB

# Use JSONB for PostgreSQL, fallback to JSON for other databases
try:
    JsonType = JSONB
except:
    JsonType = JSON

class DataQualityRule(db.Model):
    """
    Data quality validation rules for database tables and fields.
    """
    __tablename__ = 'data_quality_rule'

    id = db.Column(db.Integer, primary_key=True)
    table_name = db.Column(db.String(128), nullable=False)
    field_name = db.Column(db.String(128), nullable=True)  # Null for table-level rules
    rule_type = db.Column(db.String(64), nullable=False)  # required, format, range, referential, etc.
    rule_config = db.Column(JsonType, nullable=False)  # JSON configuration for the rule
    description = db.Column(db.Text)
    severity = db.Column(db.String(32), default='warning')  # info, warning, error, critical
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)

    def __repr__(self):
        return f"<DataQualityRule {self.id}: {self.table_name}.{self.field_name or '*'} ({self.rule_type})>"

    @property
    def config(self):
        """Return rule configuration as a dictionary"""
        if isinstance(self.rule_config, dict):
            return self.rule_config
        elif isinstance(self.rule_config, str):
            return json.loads(self.rule_config)
        return {}


class DataQualityIssue(db.Model):
    """
    Data quality issues found during validation.
    """
    __tablename__ = 'data_quality_issue'

    id = db.Column(db.Integer, primary_key=True)
    rule_id = db.Column(db.Integer, db.ForeignKey('data_quality_rule.id'), nullable=True)
    table_name = db.Column(db.String(128), nullable=False)
    field_name = db.Column(db.String(128), nullable=True)
    record_id = db.Column(db.String(128), nullable=True)  # ID of the record with the issue
    issue_type = db.Column(db.String(64), nullable=False)  # missing_value, invalid_format, out_of_range, etc.
    issue_details = db.Column(JsonType, nullable=True)  # JSON with issue details
    issue_value = db.Column(db.Text, nullable=True)  # String representation of the problematic value
    severity = db.Column(db.String(32), default='warning')  # info, warning, error, critical
    status = db.Column(db.String(32), default='open')  # open, resolved, ignored
    resolved_at = db.Column(db.DateTime, nullable=True)
    resolved_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    detected_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)

    # Relationships
    rule = db.relationship('DataQualityRule', backref=db.backref('issues', lazy='dynamic'))
    resolver = db.relationship('User', backref=db.backref('resolved_issues', lazy='dynamic'))

    def __repr__(self):
        return f"<DataQualityIssue {self.id}: {self.table_name}.{self.field_name or '*'} ({self.issue_type})>"


class DataQualityReport(db.Model):
    """
    Data quality report generated by the Data Quality Agent.
    """
    __tablename__ = 'data_quality_report'

    id = db.Column(db.Integer, primary_key=True)
    report_name = db.Column(db.String(128), nullable=False)
    report_type = db.Column(db.String(32), default='default')  # Type of report (default, monthly, custom, etc.)
    tables_checked = db.Column(JsonType, nullable=False)  # List of tables included in the report
    overall_score = db.Column(db.Float, nullable=True)  # Overall quality score (0-100)
    report_data = db.Column(JsonType, nullable=False)  # Full report data
    critical_issues = db.Column(db.Integer, default=0)  # Number of critical issues
    high_issues = db.Column(db.Integer, default=0)  # Number of high severity issues
    medium_issues = db.Column(db.Integer, default=0)  # Number of medium severity issues
    low_issues = db.Column(db.Integer, default=0)  # Number of low severity issues
    report_file_path = db.Column(db.String(255), nullable=True)  # Path to saved PDF report
    report_format = db.Column(db.String(32), default='pdf')  # Format of the report (pdf, excel, etc.)
    start_date = db.Column(db.DateTime, nullable=True)  # Start date for report period
    end_date = db.Column(db.DateTime, nullable=True)  # End date for report period
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)

    # Relationships
    creator = db.relationship('User', backref=db.backref('quality_reports', lazy='dynamic'))

    def __repr__(self):
        return f"<DataQualityReport {self.id}: {self.report_name} (Score: {self.overall_score})>"


class AnomalyDetectionConfig(db.Model):
    """
    Configuration for anomaly detection in data.
    """
    __tablename__ = 'anomaly_detection_config'

    id = db.Column(db.Integer, primary_key=True)
    table_name = db.Column(db.String(128), nullable=False)
    field_name = db.Column(db.String(128), nullable=True)  # Null for table-level config
    detection_type = db.Column(db.String(64), nullable=False)  # value_change, outlier, z_score, etc.
    config = db.Column(JsonType, nullable=False)  # JSON configuration for detection
    description = db.Column(db.Text)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)

    def __repr__(self):
        return f"<AnomalyDetectionConfig {self.id}: {self.table_name}.{self.field_name or '*'} ({self.detection_type})>"


class DataAnomaly(db.Model):
    """
    Data anomalies detected during analysis.
    """
    __tablename__ = 'data_anomaly'

    id = db.Column(db.Integer, primary_key=True)
    config_id = db.Column(db.Integer, db.ForeignKey('anomaly_detection_config.id'), nullable=True)
    table_name = db.Column(db.String(128), nullable=False)
    field_name = db.Column(db.String(128), nullable=True)
    record_id = db.Column(db.String(128), nullable=True)  # ID of the record with the anomaly
    anomaly_type = db.Column(db.String(64), nullable=False)  # value_change, outlier, etc.
    anomaly_details = db.Column(JsonType, nullable=True)  # JSON with anomaly details
    anomaly_score = db.Column(db.Float, nullable=True)  # Anomaly score or confidence
    current_value = db.Column(db.Text, nullable=True)  # String representation of current value
    previous_value = db.Column(db.Text, nullable=True)  # String representation of previous value
    severity = db.Column(db.String(32), default='warning')  # info, warning, error, critical
    status = db.Column(db.String(32), default='open')  # open, resolved, ignored
    resolved_at = db.Column(db.DateTime, nullable=True)
    resolved_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    detected_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)

    # Relationships
    config = db.relationship('AnomalyDetectionConfig', backref=db.backref('anomalies', lazy='dynamic'))
    resolver = db.relationship('User', backref=db.backref('resolved_anomalies', lazy='dynamic'))

    def __repr__(self):
        return f"<DataAnomaly {self.id}: {self.table_name}.{self.field_name or '*'} ({self.anomaly_type})>"


class DataQualityAlert(db.Model):
    """
    Alert configurations and notifications for data quality issues and anomalies.
    """
    __tablename__ = 'data_quality_alert'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    description = db.Column(db.Text)
    
    # Alert type and conditions
    alert_type = db.Column(db.String(64), nullable=False)  # issue, anomaly, score, trend
    table_name = db.Column(db.String(128), nullable=True)  # Optional filter by table
    field_name = db.Column(db.String(128), nullable=True)  # Optional filter by field
    severity_threshold = db.Column(db.String(32), default='warning')  # Minimum severity level to trigger
    
    # Alert conditions specific to the alert_type
    conditions = db.Column(JsonType, nullable=False)  # JSON with alert conditions
    
    # Recipients and delivery channels
    recipients = db.Column(JsonType, nullable=False)  # List of user IDs or email addresses
    channels = db.Column(JsonType, nullable=False)  # List of channels: email, sms, slack, in_app, etc.
    
    # Alert status and configuration
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    
    # Relationships
    creator = db.relationship('User', backref=db.backref('quality_alerts', lazy='dynamic'))
    
    def __repr__(self):
        return f"<DataQualityAlert {self.id}: {self.name} ({self.alert_type})>"


class DataQualityNotification(db.Model):
    """
    Record of notifications sent for data quality alerts.
    """
    __tablename__ = 'data_quality_notification'
    
    id = db.Column(db.Integer, primary_key=True)
    alert_id = db.Column(db.Integer, db.ForeignKey('data_quality_alert.id'), nullable=True)
    
    # Reference to the triggering entity
    issue_id = db.Column(db.Integer, db.ForeignKey('data_quality_issue.id'), nullable=True)
    anomaly_id = db.Column(db.Integer, db.ForeignKey('data_anomaly.id'), nullable=True)
    report_id = db.Column(db.Integer, db.ForeignKey('data_quality_report.id'), nullable=True)
    
    # Notification details
    title = db.Column(db.String(255), nullable=False)
    message = db.Column(db.Text, nullable=False)
    severity = db.Column(db.String(32), default='warning')  # info, warning, error, critical
    
    # Recipient and delivery information
    recipient = db.Column(db.String(255), nullable=False)  # User ID, email, or other identifier
    channel = db.Column(db.String(64), nullable=False)  # email, sms, slack, in_app
    status = db.Column(db.String(32), default='sent')  # sent, delivered, read, failed
    
    # Additional data
    notification_data = db.Column(JsonType, nullable=True)  # JSON with additional data
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    delivered_at = db.Column(db.DateTime, nullable=True)
    read_at = db.Column(db.DateTime, nullable=True)
    
    # Relationships
    alert = db.relationship('DataQualityAlert', backref=db.backref('notifications', lazy='dynamic'))
    issue = db.relationship('DataQualityIssue', backref=db.backref('notifications', lazy='dynamic'))
    anomaly = db.relationship('DataAnomaly', backref=db.backref('notifications', lazy='dynamic'))
    report = db.relationship('DataQualityReport', backref=db.backref('notifications', lazy='dynamic'))
    
    def __repr__(self):
        return f"<DataQualityNotification {self.id}: {self.title} to {self.recipient} via {self.channel}>"